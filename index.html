<!DOCTYPE html>
<html lang="en-us">

<head>
    <base href="https://cdn.jsdelivr.net/gh/web-ports/clover-pit@main/">
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Clover Pit</title>
    <meta name="description"
        content="Play Clover Pit - a fun arcade game by Panik Arcade. Your progress is saved automatically!">
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        #loading-text {
            color: #c8b6ff;
            font-size: 36px;
            font-weight: 700;
            text-align: center;
            margin-top: 24px;
            text-shadow: 0 0 20px rgba(200, 182, 255, 0.5);
            letter-spacing: 2px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        /* Save status toast */
        #save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(200, 182, 255, 0.25);
            border-radius: 12px;
            padding: 12px 20px;
            color: #c8b6ff;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 99999;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        #save-status.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        #save-status.success {
            border-color: rgba(80, 220, 120, 0.5);
            color: #50dc78;
        }

        #save-status.error {
            border-color: rgba(255, 100, 100, 0.5);
            color: #ff6464;
        }

        /* Save controls */
        #save-controls {
            position: fixed;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 99999;
            opacity: 0;
            transition: opacity 0.5s ease;
            flex-wrap: wrap;
            max-width: 500px;
            justify-content: flex-end;
        }

        #save-controls.visible {
            opacity: 1;
        }

        #save-controls button {
            background: rgba(15, 15, 25, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(200, 182, 255, 0.25);
            border-radius: 10px;
            color: #c8b6ff;
            font-size: 13px;
            font-weight: 600;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.25s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }

        #save-controls button:hover {
            background: rgba(200, 182, 255, 0.15);
            border-color: rgba(200, 182, 255, 0.5);
            transform: translateY(-1px);
        }

        #save-controls button:active {
            transform: translateY(0);
        }

        /* Auto-save dot indicator */
        #autosave-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 99999;
        }

        #autosave-indicator.visible {
            opacity: 1;
        }

        #autosave-indicator .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #50dc78;
            box-shadow: 0 0 8px rgba(80, 220, 120, 0.5);
            animation: dot-pulse 2s ease-in-out infinite;
        }

        #autosave-indicator .label {
            color: rgba(200, 200, 220, 0.5);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        @keyframes dot-pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div id="loading-text">LOADING...</div>

    <div id="unity-container">
        <canvas id="unity-canvas" width=960 height=540 tabindex="-1"></canvas>
        <div id="unity-loading-bar">
            <div id="unity-logo"></div>
            <div id="unity-progress-bar-empty">
                <div id="unity-progress-bar-full"></div>
            </div>
        </div>
        <div id="unity-warning"> </div>
    </div>

    <div id="save-controls">
        <button id="btn-save" title="Manually sync save data to browser storage">
            <span>üíæ</span> Save Now
        </button>
        <button id="btn-check" title="Run save system diagnostics">
            <span>üîç</span> System Check
        </button>
        <button id="btn-export" title="Export your save data as a downloadable file">
            <span>üì§</span> Export Save
        </button>
        <button id="btn-import" title="Import a previously exported save file">
            <span>üì•</span> Import Save
        </button>
    </div>

    <div id="autosave-indicator">
        <div class="dot"></div>
        <span class="label">AUTO-SAVE ON</span>
    </div>

    <div id="save-status">
        <span class="icon"></span>
        <span class="text"></span>
    </div>

    <!-- Diagnostic Overlay -->
    <div id="diagnostic-overlay"
        style="display: none; position: fixed; top: 60px; right: 12px; width: 350px; background: rgba(10, 10, 15, 0.95); border: 1px solid rgba(200, 182, 255, 0.3); border-radius: 12px; padding: 15px; color: #c8b6ff; font-family: monospace; font-size: 12px; z-index: 100000; box-shadow: 0 8px 32px rgba(0,0,0,0.8); backdrop-filter: blur(10px);">
        <div
            style="display: flex; justify-content: space-between; margin-bottom: 10px; border-bottom: 1px solid rgba(200, 182, 255, 0.2); padding-bottom: 5px;">
            <b style="color: #fff;">üíæ SAVE SYSTEM DIAGNOSTICS</b>
            <span id="close-diag" style="cursor: pointer; opacity: 0.6;">[X]</span>
        </div>
        <div id="diag-content" style="max-height: 400px; overflow-y: auto; line-height: 1.4;">
            Fetching status...
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(200, 182, 255, 0.2);">
            <button id="btn-test-save"
                style="width: 100%; background: #50dc78; color: #000; border: none; padding: 6px; border-radius: 4px; font-weight: bold; cursor: pointer;">üß™
                FORCE SYNC TEST</button>
        </div>
    </div>

    <input type="file" id="import-file-input" accept=".json,.cloverpit" style="display: none;">

    <!-- ================================================================
         FRAMEWORK PATCHER (v7)
         ================================================================ -->
    <script>
        (function () {
            var _origCreateElement = document.createElement.bind(document);
            document.createElement = function (tagName) {
                var el = _origCreateElement(tagName);
                if (tagName.toLowerCase() === 'script') {
                    var _origSrc = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src');
                    var _patchApplied = false;

                    Object.defineProperty(el, 'src', {
                        set: function (url) {
                            if (!_patchApplied && typeof url === 'string' && url.indexOf('framework') !== -1) {
                                _patchApplied = true;
                                console.log('[SaveSystem] Intercepting framework:', url);
                                fetch(url).then(r => r.text()).then(src => {
                                    // Patch targets found via Node.js search
                                    var target = 'Module.__unityIdbfsMount=FS.mount';
                                    var patch = 'window.__gameFS=FS;window.__gameIDBFS=IDBFS;Module.__unityIdbfsMount=FS.mount';
                                    if (src.indexOf(target) !== -1) {
                                        src = src.replace(target, patch);
                                        console.log('[SaveSystem] ‚úì Framework extension injected!');
                                    } else {
                                        console.warn('[SaveSystem] ‚úó Could not find patch target. Trying fallback...');
                                        src = src.replace('FS.mkdir("/idbfs")', 'window.__gameFS=FS;window.__gameIDBFS=IDBFS;FS.mkdir("/idbfs")');
                                    }
                                    var blobUrl = URL.createObjectURL(new Blob([src], { type: 'application/javascript' }));
                                    _origSrc.set.call(el, blobUrl);
                                }).catch(err => {
                                    console.error('[SaveSystem] Patch error:', err);
                                    _origSrc.set.call(el, url);
                                });
                            } else {
                                _origSrc.set.call(el, url);
                            }
                        },
                        get: function () { return _origSrc.get.call(el); },
                        configurable: true
                    });
                }
                return el;
            };
        })();
    </script>

    <script>
        // =========================================================================
        //  SAVE SYSTEM v7
        // =========================================================================
        const AUTOSAVE_INTERVAL_MS = 30000;
        const PRODUCT_NAME = 'CloverPit';

        let unityInstance = null;
        let autoSaveTimer = null;
        let isFSSyncing = false;

        function showSaveStatus(message, type = 'info') {
            const el = document.getElementById('save-status');
            el.querySelector('.icon').textContent = { info: 'üíæ', success: '‚úÖ', error: '‚ùå' }[type] || 'üíæ';
            el.querySelector('.text').textContent = message;
            el.className = 'visible ' + type;
            clearTimeout(el._hideTimer);
            el._hideTimer = setTimeout(() => { el.className = ''; }, 4000);
        }

        // ---- Smarter Sync Strategy ----
        async function syncFS(showNotification = true) {
            if (isFSSyncing) return;
            isFSSyncing = true;
            if (showNotification) showSaveStatus('Saving...', 'info');

            const results = {
                strategy1: 'skip', strategy2: 'skip', strategy3: 'skip'
            };

            const callback = (err) => {
                isFSSyncing = false;
                if (err) {
                    console.error('[SaveSystem] Sync failed:', err);
                    if (showNotification) showSaveStatus('Save failed!', 'error');
                } else {
                    console.log('[SaveSystem] ‚úì Persistence synchronized');
                    if (showNotification) showSaveStatus('Progress saved!', 'success');
                }
            };

            try {
                // Strategy 1: Captured FS (from patch)
                if (window.__gameFS && typeof window.__gameFS.syncfs === 'function') {
                    results.strategy1 = 'trying...';
                    window.__gameFS.syncfs(false, callback);
                    return;
                }

                // Strategy 2: Unity IDBFS Mount via instance
                const mount = unityInstance?.Module?.__unityIdbfsMount;
                const mnt = mount?.mount;

                if (mount?.type?.syncfs) {
                    results.strategy2 = 'trying mount.type.syncfs...';
                    mount.type.syncfs(mount, false, callback);
                    return;
                }

                // Strategy 3: IDBFS queuePersist (from framework)
                if (mnt?.type?.queuePersist) {
                    results.strategy3 = 'trying mnt.type.queuePersist...';
                    mnt.type.queuePersist(mnt);
                    // queuePersist is usually async but doesn't have a direct callback in all versions
                    // but we'll assume it works if called
                    setTimeout(() => callback(null), 500);
                    return;
                }

                // Strategy 4: Fallback to global IDBFS if available
                if (window.__gameIDBFS && mnt) {
                    window.__gameIDBFS.queuePersist(mnt);
                    setTimeout(() => callback(null), 500);
                    return;
                }

                isFSSyncing = false;
                if (showNotification) showSaveStatus('FS not ready', 'error');
                console.warn('[SaveSystem] No sync strategy available. Results:', results);
            } catch (e) {
                isFSSyncing = false;
                console.error('[SaveSystem] Sync ERROR:', e);
                if (showNotification) showSaveStatus('Save error', 'error');
            }
        }

        // ---- Diagnostics ----
        async function runDiagnostics() {
            const diag = document.getElementById('diag-content');
            const overlay = document.getElementById('diagnostic-overlay');
            overlay.style.display = 'block';
            diag.innerHTML = 'Scanning runtime...<br>---<br>';

            const check = (label, val) => {
                const color = val ? '#50dc78' : '#ff6464';
                diag.innerHTML += `${label}: <span style="color:${color}">${val ? (typeof val === 'object' ? 'OK (obj)' : val) : 'MISSING'}</span><br>`;
            };

            check('window.__gameFS', !!window.__gameFS);
            check('window.__gameIDBFS', !!window.__gameIDBFS);
            check('unityInstance', !!unityInstance);

            const module = unityInstance?.Module;
            check('Module', !!module);

            const mount = module?.__unityIdbfsMount;
            check('__unityIdbfsMount', !!mount);

            if (mount) {
                check('Mount.mount', !!mount.mount);
                check('Mount.type', !!mount.type);
                check('Mount.type.syncfs', !!mount.type?.syncfs);
                check('Mount.mount.type.queuePersist', !!mount.mount?.type?.queuePersist);
            }

            // Check IndexedDB
            diag.innerHTML += '<br><b>IndexedDB Check:</b><br>';
            try {
                const dbs = await indexedDB.databases();
                dbs.forEach(db => {
                    diag.innerHTML += `- ${db.name} (v${db.version})<br>`;
                });
                if (dbs.length === 0) diag.innerHTML += 'No databases found.<br>';
            } catch (e) { diag.innerHTML += 'DB list error.<br>'; }

            // Check /idbfs contents
            if (window.__gameFS) {
                try {
                    const files = window.__gameFS.readdir('/idbfs');
                    diag.innerHTML += `<br><b>File Count in /idbfs:</b> ${files.length}<br>`;
                    files.slice(0, 5).forEach(f => diag.innerHTML += `- ${f}<br>`);
                } catch (e) { }
            }
        }

        // ---- Export/Import ----
        async function exportSaveData() {
            try {
                showSaveStatus('Exporting...', 'info');
                await syncFS(false);
                const exportData = { version: 3, game: PRODUCT_NAME, timestamp: new Date().toISOString(), databases: {} };
                let dbNames = ['/idbfs'];
                if (indexedDB.databases) {
                    const dbs = await indexedDB.databases();
                    dbs.forEach(d => { if (d.name && !dbNames.includes(d.name)) dbNames.push(d.name); });
                }
                for (let name of dbNames) {
                    try { exportData.databases[name] = await exportIDB(name); } catch (e) { }
                }
                const prefs = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const k = localStorage.key(i); prefs[k] = localStorage.getItem(k);
                }
                exportData.playerPrefs = prefs;
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `CloverPit_Save_${new Date().toISOString().slice(0, 10)}.cloverpit`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                showSaveStatus('Exported!', 'success');
            } catch (e) { showSaveStatus('Export error', 'error'); }
        }

        function exportIDB(dbName) {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName);
                req.onerror = () => reject(req.error);
                req.onsuccess = () => {
                    const db = req.result;
                    const names = Array.from(db.objectStoreNames);
                    if (!names.length) { db.close(); resolve({}); return; }
                    const tx = db.transaction(names, 'readonly');
                    const data = {}; let done = 0;
                    names.forEach(name => {
                        const store = tx.objectStore(name);
                        const kReq = store.getAllKeys();
                        const vReq = store.getAll();
                        Promise.all([
                            new Promise(r => kReq.onsuccess = () => r(kReq.result)),
                            new Promise(r => vReq.onsuccess = () => r(vReq.result))
                        ]).then(([keys, vals]) => {
                            data[name] = {
                                keys, values: vals.map(v => {
                                    if (v instanceof ArrayBuffer) return { __t: 'AB', d: Array.from(new Uint8Array(v)) };
                                    if (v?.contents instanceof Uint8Array) return { ...v, contents: { __t: 'U8', d: Array.from(v.contents) } };
                                    return v;
                                })
                            };
                            if (++done === names.length) { db.close(); resolve(data); }
                        });
                    });
                };
            });
        }

        async function importSaveData(file) {
            try {
                showSaveStatus('Importing...', 'info');
                const data = JSON.parse(await file.text());
                if (data.game !== PRODUCT_NAME) return showSaveStatus('Wrong file!', 'error');
                for (let [db, content] of Object.entries(data.databases)) await importIDB(db, content);
                if (data.playerPrefs) Object.entries(data.playerPrefs).forEach(([k, v]) => localStorage.setItem(k, v));
                showSaveStatus('Success! Reloading...', 'success');
                setTimeout(() => location.reload(), 1500);
            } catch (e) { showSaveStatus('Import failed', 'error'); }
        }

        function importIDB(dbName, storeData) {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    Object.keys(storeData).forEach(n => { if (!db.objectStoreNames.contains(n)) db.createObjectStore(n); });
                };
                req.onsuccess = () => {
                    const db = req.result;
                    const names = Object.keys(storeData).filter(n => db.objectStoreNames.contains(n));
                    if (!names.length) { db.close(); resolve(); return; }
                    const tx = db.transaction(names, 'readwrite');
                    names.forEach(n => {
                        const store = tx.objectStore(n);
                        const { keys, values } = storeData[n];
                        store.clear();
                        keys.forEach((k, i) => {
                            let v = values[i];
                            if (v?.__t === 'AB') v = new Uint8Array(v.d).buffer;
                            if (v?.contents?.__t === 'U8') v = { ...v, contents: new Uint8Array(v.contents.d) };
                            store.put(v, k);
                        });
                    });
                    tx.oncomplete = () => { db.close(); resolve(); };
                };
            });
        }

        // Event Listeners
        document.getElementById('btn-save').onclick = () => syncFS(true);
        document.getElementById('btn-check').onclick = runDiagnostics;
        document.getElementById('btn-export').onclick = exportSaveData;
        document.getElementById('btn-import').onclick = () => document.getElementById('import-file-input').click();
        document.getElementById('btn-test-save').onclick = () => syncFS(true);
        document.getElementById('close-diag').onclick = () => document.getElementById('diagnostic-overlay').style.display = 'none';
        document.getElementById('import-file-input').onchange = (e) => {
            if (e.target.files[0] && confirm('Overwrite current save?')) importSaveData(e.target.files[0]);
        };

        window.onbeforeunload = () => { if (window.__gameFS) window.__gameFS.syncfs(false, () => { }); };
        document.onvisibilitychange = () => { if (document.visibilityState === 'hidden') syncFS(false); };

        function startAutoSave() {
            if (autoSaveTimer) clearInterval(autoSaveTimer);
            autoSaveTimer = setInterval(() => syncFS(false), AUTOSAVE_INTERVAL_MS);
        }

        // ---- Game Loader ----
        var loadingText = document.querySelector("#loading-text");
        let loadedBytes = 0;
        async function fetchWithProgress(url) {
            const r = await fetch(url);
            const reader = r.body.getReader();
            let chunks = [], received = 0;
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                received += value.length; loadedBytes += value.length; chunks.push(value);
                loadingText.textContent = `LOADING... ${(loadedBytes / 1048576).toFixed(2)} MB / 86.96 MB`;
            }
            let b = new Uint8Array(received), o = 0;
            chunks.forEach(c => { b.set(c, o); o += c.length; });
            return b.buffer;
        }
        async function mergeFiles(parts, mime) {
            const bufs = await Promise.all(parts.map(p => fetchWithProgress(p)));
            return URL.createObjectURL(new Blob(bufs, mime ? { type: mime } : {}));
        }
        function getParts(f, s, e) { return Array.from({ length: e - s + 1 }, (_, i) => `${f}.part${i + s}`); }

        (async () => {
            const [dataUrl, wasmUrl] = await Promise.all([
                mergeFiles(getParts("Build/CloverPit.data", 1, 3), 'application/octet-stream'),
                mergeFiles(getParts("Build/CloverPit.wasm", 1, 3), 'application/wasm'),
            ]);
            var canvas = document.querySelector("#unity-canvas");
            var loadingBar = document.querySelector("#unity-loading-bar");
            var progressBarFull = document.querySelector("#unity-progress-bar-full");
            var config = {
                dataUrl, wasmUrl,
                frameworkUrl: "Build/CloverPit.framework.js",
                streamingAssetsUrl: "StreamingAssets",
                companyName: "Panik Arcade", productName: "CloverPit", productVersion: "1.3",
                showBanner: (m, t) => console.log(`[Unity] ${t}: ${m}`),
                autoSyncPersistentDataPath: true,
            };

            loadingBar.style.display = "block";
            var s = document.createElement("script");
            s.src = "Build/CloverPit.loader.js";
            s.onload = () => {
                createUnityInstance(canvas, config, (p) => {
                    progressBarFull.style.width = (100 * p) + "%";
                }).then((instance) => {
                    unityInstance = instance;
                    loadingBar.style.display = "none";
                    loadingText.remove();
                    document.getElementById('save-controls').classList.add('visible');
                    document.getElementById('autosave-indicator').classList.add('visible');
                    startAutoSave();
                    console.log('[SaveSystem] Game loaded, verify with System Check');
                }).catch(err => console.error('[Unity] Startup error:', err));
            };
            document.body.appendChild(s);
        })();
    </script>
</body>

</html>

</body>

</html>
